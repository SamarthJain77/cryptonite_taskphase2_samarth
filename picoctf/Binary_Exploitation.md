# heap 0

## Description
Are overflows just a stack concern?
Download the binary here.
Download the source here.
Additional details will be available after launching your challenge instance.

## Attachment
- https://artifacts.picoctf.net/c_tethys/13/chall
- https://artifacts.picoctf.net/c_tethys/13/chall.c
- Connect with the challenge instance here: nc tethys.picoctf.net 59329

## Hint
What part of the heap do you have control over and how far is it from the safe_var?

## Writeup
After reading the challenge description and the given hint, I realized that I needed to do something with heap overflow.
On surfing the internet, I learned that heap is a region of processâ€™s memory which is used to store dynamic variables. 
It is possible to allocate memory on heap using functions like `malloc` or `calloc` but once we do that, we need to make sure that we free that memory space using `free()` after use to avoid overflow.
Upon going through the source code file, I noticed that the program allocates two variables `input_data` and `safe_var` on the heap initialized with `pico` and `bico` respectively.
There's a part in the source code which clearly indicates that modifying the content of `safe_var` will trigger the program to print the flag:
```
void check_win() {
    if (strcmp(safe_var, "bico") != 0) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

        exit(0);
    } else {
        printf("Looks like everything is still secure!\n");
        printf("\nNo flage for you :(\n");
        fflush(stdout);
    }
}
```
Then I noticed the `write_buffer()` function in the source code which allows us to write data directly to `input_data`:
```
void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}
```
Here the `scanf` function is not instructed to check the size of input data which means it can overflow the `input_data` buffer allowing us to overwrite `safe_var`.
On connecting with the challenge instance, the current state of the heap was displayed along with the heap address of both the variables:
```
Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x595af4baf2b0  ->   pico
+-------------+----------------+
[*]   0x595af4baf2d0  ->   bico
+-------------+----------------+
```
The address of `input_data` is `0x595af4baf2b0` and the address of `safe_var` is `0x595af4baf2d0` and both are in hexadecimal format.
I then converted it to decimal number system using the converter found at `https://www.rapidtables.com/convert/number/hex-to-decimal.html`, which revealed the addresses as `98247187821232` and `98247187821264` respectively.
I then understood that to determine the exact string length required to overwrite `safe_var`, I need to find the difference between them that is `32` and then input a string of atleast `33` characters to `input_data` to overwrite `safe_var`.
Then I analyzed the heap menu and entered the choice as `2`.
```
1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 2
```
The program asked for `Data for buffer:` where I gave the string `ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFG` as the input and then I entered the choice as `4` which gave the output `YOU WIN` and led me to the flag: `picoCTF{my_first_heap_overflow_4fa6dd49}`.

# format string 0

## Description
Can you use your knowledge of format strings to make the customers happy?
Download the binary here.
Download the source here.
Additional details will be available after launching your challenge instance.

## Attachment
- https://artifacts.picoctf.net/c_mimas/69/format-string-0
- https://artifacts.picoctf.net/c_mimas/69/format-string-0.c
- Connect with the challenge instance here: nc mimas.picoctf.net 62466

## Hints
- This is an introduction of format string vulnerabilities. Look up "format specifiers" if you have never seen them before.
- Just try out the different options.

## Writeup
After reading the challenge description and the given hints, I realized that I needed to do something with the format specifiers.
Format specifiers are used in C programming language to take input and display the output of a specific type. 
We use the `%` symbol in every format specifier. 
Format specifiers tell the compiler about the type of data that must be taken as input and the type of data that must be printed on the screen as output. 
On connecting with the challenge instance, I got to know that we are roleplaying in a newly-opened burger place `Pico 'n Patty`! 
My work was to help the picky customers find their favorite burger. 
The first customer was `Patrick` who wanted a giant bite. 
I had to choose a burger from the following options: `Breakf@st_Burger`, `Gr%114d_Cheese`, `Bac0n_D3luxe`. 
I kept in mind the format specifiers and chose `Gr%114d_Cheese`. 
Patrick went away happily and second customer `Sponge Bob` arrived who wanted something outrageous that would break the shop. 
I had to choose a burger from the following options: `Pe%to_Portobello`, `$outhwest_Burger`, `Cla%sic_Che%s%steak`. 
Again keeping in mind the format specifiers, I chose `Cla%sic_Che%s%steak` which led me to the flag: `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_dc0f36c4}`.
