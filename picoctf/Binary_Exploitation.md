# heap 0

## Description
Are overflows just a stack concern?
Download the binary here.
Download the source here.
Additional details will be available after launching your challenge instance.

## Attachment
- https://artifacts.picoctf.net/c_tethys/13/chall
- https://artifacts.picoctf.net/c_tethys/13/chall.c
- Connect with the challenge instance here: nc tethys.picoctf.net 59329

## Hint
What part of the heap do you have control over and how far is it from the safe_var?

## Writeup
After reading the challenge description and the given hint, I realized that I needed to do something with heap overflow.
On surfing the internet, I learned that heap is a region of processâ€™s memory which is used to store dynamic variables. 
It is possible to allocate memory on heap using functions like `malloc` or `calloc` but once we do that, we need to make sure that we free that memory space using `free()` after use to avoid overflow.
Upon going through the source code file, I noticed that the program allocates two variables `input_data` and `safe_var` on the heap initialized with `pico` and `bico` respectively.
Then I noticed a part in the source code which clearly stated that modifying the content of `safe_var` will trigger the program to print the flag.
Also I saw the `write_buffer()` function in the source code which allows us to write data directly to `input_data` but the thing is that the `scanf` function mentioned in the code of `write_buffer()` function is not instructed to check the size of input data which means it can overflow the `input_data` buffer allowing us to overwrite `safe_var`.
On connecting with the challenge instance, the current state of the heap was displayed through which I got to know that the address of `input_data` is `0x595af4baf2b0` and the address of `safe_var` is `0x595af4baf2d0` and both are in hexadecimal format.
I then converted it to decimal number system using the converter found at `https://www.rapidtables.com/convert/number/hex-to-decimal.html`, which revealed the addresses as `98247187821232` and `98247187821264` respectively.
I then understood that to determine the exact string length required to overwrite `safe_var`, I need to find the difference between them that is `32` and then input a string of atleast `33` characters to `input_data` to overwrite `safe_var` as it is an adjacent variable which means storage of `input_data` ends where storage of `safe_var` begins.
Then I analyzed the heap menu and entered the choice as `2`.
The program asked for `Data for buffer:` where I gave the string `ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFG` as the input and then I entered the choice as `4` which gave the output `YOU WIN` and led me to the flag: `picoCTF{my_first_heap_overflow_4fa6dd49}`.

# format string 0

## Description
Can you use your knowledge of format strings to make the customers happy?
Download the binary here.
Download the source here.
Additional details will be available after launching your challenge instance.

## Attachment
- https://artifacts.picoctf.net/c_mimas/69/format-string-0
- https://artifacts.picoctf.net/c_mimas/69/format-string-0.c
- Connect with the challenge instance here: nc mimas.picoctf.net 62466

## Hints
- This is an introduction of format string vulnerabilities. Look up "format specifiers" if you have never seen them before.
- Just try out the different options.

## Writeup
After reading the challenge description and the given hints, I realized that I needed to do something with the format specifiers.
Format specifiers are used in C programming language to take input and display the output of a specific type. 
We use the `%` symbol in every format specifier. 
Format specifiers tell the compiler about the type of data that must be taken as input and the type of data that must be printed on the screen as output. 
On connecting with the challenge instance, I got to know that we are roleplaying in a newly-opened burger place `Pico 'n Patty`! 
My work was to help the picky customers find their favorite burger. 
The first customer was `Patrick` who wanted a giant bite. 
I had to choose a burger from the following options: `Breakf@st_Burger`, `Gr%114d_Cheese`, `Bac0n_D3luxe`.
Upon going through the source code file, I noticed that the program checks if the choice I made exceeds `2*BUFSIZE` bytes where `BUFSIZE` is defined as `32` bytes so I kept in mind the condition and format specifiers and chose `Gr%114d_Cheese` as it can print some garbage data inflating the count to `114` characters which exceeds the requirement of `64` bytes.
Patrick went away happily and second customer `Sponge Bob` arrived who wanted something outrageous that would break the shop. 
I had to choose a burger from the following options: `Pe%to_Portobello`, `$outhwest_Burger`, `Cla%sic_Che%s%steak`. 
Again keeping in mind the format specifiers, I chose `Cla%sic_Che%s%steak` which led me to the flag: `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_dc0f36c4}`.

# buffer overflow 0

## Description
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Additional details will be available after launching your challenge instance.

## Attachment
- https://artifacts.picoctf.net/c/172/vuln
- https://artifacts.picoctf.net/c/172/vuln.c
- Connect using: nc saturn.picoctf.net 53878

## Hints
- How can you trigger the flag to print?
- If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.
- Run man gets and read the BUGS section. How many characters can the program really read?

## Writeup
After reading the challenge description and upon going through the source code file, I realized that I needed to do something with array overflow.
An array is a fixed size collection of similar data items stored in continuous memory locations.
Overflow occurs when a program tries to access or write data beyond the specified boundaries of an array.
I noticed that the `sigsegv_handler` function needs to be triggered to get the flag.
I also noticed that the `vuln` function is defined to copy the input given by user to an array named `buf2` which is defined as a `char` with a size of `16` bytes using `strcpy` function which means I could overflow it by giving any input longer than 16 characters.
On connecting with the challenge instance, the program asked for `Input:` where I gave the string `ABCDEFGHIJKLMNOPQRSTUVWXYZ` as the input which led me to the flag: `picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}`.
