# heap 0

## Description
Are overflows just a stack concern?
Download the binary here.
Download the source here.
Additional details will be available after launching your challenge instance.

## Attachments
- https://artifacts.picoctf.net/c_tethys/13/chall
- https://artifacts.picoctf.net/c_tethys/13/chall.c
- Connect with the challenge instance here: `nc tethys.picoctf.net 59329`

## Hint
What part of the heap do you have control over and how far is it from the safe_var?

## Writeup
After reading the challenge description and the given hint, I realized that I needed to do something with heap overflow.
On surfing the internet, I learned that heap is a region of processâ€™s memory which is used to store dynamic variables. 
It is possible to allocate memory on heap using functions like `malloc` or `calloc` but once we do that, we need to make sure that we free that memory space using `free()` after use to avoid overflow.
Upon going through the source code file, I noticed that the program allocates two variables `input_data` and `safe_var` on the heap initialized with `pico` and `bico` respectively.
Then I noticed a part in the source code which clearly stated that modifying the content of `safe_var` will trigger the program to print the flag.
Also I saw the `write_buffer()` function in the source code which allows us to write data directly to `input_data` but the thing is that the `scanf` function mentioned in the code of `write_buffer()` function is not instructed to check the size of input data which means it can overflow the `input_data` buffer allowing us to overwrite `safe_var`.
On connecting with the challenge instance, the current state of the heap was displayed through which I got to know that the address of `input_data` is `0x595af4baf2b0` and the address of `safe_var` is `0x595af4baf2d0` and both are in hexadecimal format.
I then converted it to decimal number system using the converter found at `https://www.rapidtables.com/convert/number/hex-to-decimal.html`, which revealed the addresses as `98247187821232` and `98247187821264` respectively.
I then understood that to determine the exact string length required to overwrite `safe_var`, I need to find the difference between them that is `32` and then input a string of atleast `33` characters to `input_data` to overwrite `safe_var` as it is an adjacent variable which means storage of `input_data` ends where storage of `safe_var` begins.
Then I analyzed the heap menu and entered the choice as `2`.
The program asked for `Data for buffer:` where I gave the string `ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFG` as the input and then I entered the choice as `4` which gave the output `YOU WIN` and led me to the flag: `picoCTF{my_first_heap_overflow_4fa6dd49}`.
